<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Wowchemy 5.6.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=author content="Florian Oswald"><meta name=description content="I am getting into estimating mixture models at the moment. In particular in the context of models of wage formation where unobserved heterogeneity stemming from both firm and worker side is often modeled with a mixture model."><link rel=alternate hreflang=en-us href=https://floswald.github.io/post/em-benchmarks/><meta name=theme-color content="#ff3e28"><link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css integrity="sha512-W0xM4mr6dEP9nREo7Z9z+9X70wytKvMGeDsj7ps2+xg5QPrEBXC8tAW1IFnzjR6eoJ90JmCnFzerQJTLzIEHjA==" crossorigin=anonymous media=print onload='this.media="all"'><link rel=stylesheet href=/css/wowchemy.ef86dd41c153a9137554f715dac728ab.css><link rel=stylesheet href=/css/libs/chroma/github-light.min.css title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=/css/libs/chroma/dracula.min.css title=hl-dark media=print onload='this.media="all"' disabled><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","G-3DVJJTSL8D")</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://floswald.github.io/post/em-benchmarks/><meta property="twitter:card" content="summary"><meta property="twitter:site" content="@FlorianOswald"><meta property="twitter:creator" content="@FlorianOswald"><meta property="og:site_name" content="Florian Oswald"><meta property="og:url" content="https://floswald.github.io/post/em-benchmarks/"><meta property="og:title" content="EM Benchmarks | Florian Oswald"><meta property="og:description" content="I am getting into estimating mixture models at the moment. In particular in the context of models of wage formation where unobserved heterogeneity stemming from both firm and worker side is often modeled with a mixture model."><meta property="og:image" content="https://floswald.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png"><meta property="twitter:image" content="https://floswald.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2019-07-06T09:56:47+02:00"><meta property="article:modified_time" content="2019-07-06T09:56:47+02:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://floswald.github.io/post/em-benchmarks/"},"headline":"EM Benchmarks","datePublished":"2019-07-06T09:56:47+02:00","dateModified":"2019-07-06T09:56:47+02:00","author":{"@type":"Person","name":"Florian Oswald"},"publisher":{"@type":"Organization","name":"Florian Oswald","logo":{"@type":"ImageObject","url":"https://floswald.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_3.png"}},"description":"I am getting into estimating mixture models at the moment. In particular in the context of models of wage formation where unobserved heterogeneity stemming from both firm and worker side is often modeled with a mixture model."}</script><title>EM Benchmarks | Florian Oswald</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=3f81a55bbb8ecc7ffdbc7b967257c582><script src=/js/wowchemy-init.min.b786ef1d12cd3ec541b225b3696a3cf1.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=Close><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control aria-label=Search...></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Florian Oswald</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Florian Oswald</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/#about><span>Home</span></a></li><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>Research</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/#publications><span>Publications</span></a>
<a class=dropdown-item href=/#publications_selected><span>Working Papers</span></a>
<a class=dropdown-item href=/#projects><span>Projects</span></a></div></li><li class=nav-item><a class=nav-link href=/#teaching><span>Teaching</span></a></li><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" data-toggle=dropdown aria-haspopup=true><span>Miscellaneous</span><span class=caret></span></a><div class=dropdown-menu><a class=dropdown-item href=/computing><span>Computing</span></a>
<a class=dropdown-item href=/research-assistants><span>Research Assistants</span></a>
<a class=dropdown-item href=/#talks><span>Talks</span></a>
<a class=dropdown-item href=/#posts><span>Blog</span></a></div></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true aria-label="Display preferences"><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span>
</a><a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span>
</a><a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav></header></div><div class=page-body><article class=article><div class="article-container pt-3"><h1>EM Benchmarks</h1><div class=article-metadata><span class=article-date>Jul 6, 2019
</span><span class=middot-divider></span>
<span class=article-reading-time>7 min read</span></div></div><div class=article-container><div class=article-style><p>I am getting into estimating mixture models at the moment. In particular in the context of models of wage formation where unobserved heterogeneity stemming from both firm and worker side is often modeled with a mixture model. The main assumptions are that</p><ol><li>Firms are classifiable into types $l \in \{1,\dots,L\}$, workers into $k \in \{1,\dots,K\}$</li><li>If Worker $i$ is of type $k$ and works for firm $l$ in a certain period, their wages are drawn from distribution $\mathcal{N}(\mu_{k,l},\sigma_{k,l})$.</li></ol><p>This kind of model is at the current frontier of econometrics, and a recent paper is <a href=https://www.econometricsociety.org/publications/econometrica/2019/05/01/distributional-framework-matched-employer-employee-data target=_blank rel=noopener>Bonhomme, Lamadon and Manresa (Econometrica 2019)</a>, ungated <a href=http://www.lamadon.com/paper/blm.pdf target=_blank rel=noopener>here</a>, with a great <a href=https://github.com/tlamadon/blm-replicate target=_blank rel=noopener>replication package in <code>R</code></a>.</p><p>The estimation of such models often involves using the <a href=https://en.wikipedia.org/wiki/Expectation%e2%80%93maximization_algorithm target=_blank rel=noopener>EM-Algorithm</a>, which I won&rsquo;t describe in detail here.</p><h2 id=weapon-of-choice>Weapon of Choice?</h2><p>Now before getting to the full model above, I wanted to know my options in terms of programming language. I decided to benchmark a simple version of the above problem: there is only one firm type (<em>all workers at the same firm</em>), and there are only two worker types, $K=2$. I am considering two options in terms of language: <code>R</code> and <code>julia</code>.</p><p>I&rsquo;ll do a hand-coded version in each language, as well as use a package from each:</p><ul><li>Hand-coding is relevant because my final problem will need some modification of existing algorithms.</li><li>Packages are relevant because they often provide efficient implementations, and could be the building block on which my extension is based.</li></ul><p>Here goes!</p><h3 id=benchmark-setup>Benchmark Setup</h3><p>I will benchmark everything out of a <code>julia</code> session by relying on the <a href=https://github.com/JuliaInterop/RCall.jl target=_blank rel=noopener><code>RCall.jl</code></a> package (<a href=https://github.com/floswald/EMbench.jl target=_blank rel=noopener>benchmark code on this repo</a>). <code>RCall.jl</code> launches an <code>R</code> session from within <code>julia</code> and allows to go back and forth with surprisingly little overhead (accesses the same locations in RAM, so no data is copied). The advantage of this is that I can create the exact same benchmarking data to test in both languages. So all code you see here is valid <code>julia</code>, even though sometimes it contains some <code>R</code>. Cool, right?🕺</p><p>Here is the data creator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=k>function</span> <span class=n>sdata</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>n</span><span class=p>;</span> <span class=n>doplot</span> <span class=o>=</span> <span class=nb>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>Random</span><span class=o>.</span><span class=n>seed!</span><span class=p>(</span><span class=mi>3333</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c># true values</span>
</span></span><span class=line><span class=cl>    <span class=n>μ</span> <span class=o>=</span> <span class=p>[</span><span class=mf>2.0</span><span class=p>,</span><span class=mf>5.0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>σ</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.5</span><span class=p>,</span><span class=mf>0.7</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>α</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.3</span><span class=p>,</span><span class=mf>0.7</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>m</span> <span class=o>=</span> <span class=n>MixtureModel</span><span class=p>([</span><span class=n>Normal</span><span class=p>(</span><span class=n>μ</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>σ</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>1</span><span class=o>:</span><span class=mi>2</span><span class=p>],</span> <span class=n>α</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>doplot</span>
</span></span><span class=line><span class=cl>        <span class=n>plot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>plot</span><span class=p>(</span><span class=n>m</span><span class=p>,</span><span class=n>linewidth</span><span class=o>=</span><span class=mi>2</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>            <span class=n>plot</span><span class=p>(</span><span class=n>m</span><span class=p>,</span><span class=n>linewidth</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>fill</span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=ss>:red</span><span class=p>,</span><span class=mf>0.5</span><span class=p>),</span> <span class=n>components</span> <span class=o>=</span> <span class=nb>false</span><span class=p>,</span> <span class=n>title</span><span class=o>=</span><span class=s>&#34;Mixture&#34;</span><span class=p>),</span><span class=n>dpi</span> <span class=o>=</span> <span class=mi>300</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>savefig</span><span class=p>(</span><span class=s>&#34;mixtures.png&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>rand</span><span class=p>(</span><span class=n>m</span><span class=p>,</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kt>Dict</span><span class=p>(</span><span class=ss>:y</span> <span class=o>=&gt;</span> <span class=n>y</span><span class=p>,</span> <span class=ss>:μ</span> <span class=o>=&gt;</span> <span class=n>μ</span><span class=p>,</span> <span class=ss>:σ</span> <span class=o>=&gt;</span> <span class=n>σ</span><span class=p>,</span> <span class=ss>:α</span> <span class=o>=&gt;</span> <span class=n>α</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><ul><li>sets true mixture parameters</li><li>creates a <code>Distributions.MixtureModel</code> data type</li><li>optionally makes a plot from it</li><li>draws <code>n</code> random realizations from it</li></ul><p>The setup looks like this:</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/img/EM-mixtures.png alt="benchmark data" loading=lazy data-zoomable></div></div></figure></p><p>All benchmarks will now proceed in the same way:</p><ol><li>Take vector <code>y</code></li><li>set (the same) wrong starting values</li><li>run the EM algorithm for <code>iters</code> iterations to find true values of proportion weights $\alpha$, means $\mu$ and variances $\sigma$ for each component.</li><li>Notice that the starting values are such that the algorithm never fully recovers the true values. Given it&rsquo;s the same data, however, each implementation will follow the same path for parameter values and run the same number of iterations (again, none until convergence).</li></ol><h3 id=julia-by-hand><code>julia</code> by hand</h3><p>Here is my relatively naive and <em>just-copy-thy-math</em> implemenation in <code>julia</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=k>function</span> <span class=n>bm_jl</span><span class=p>(</span><span class=n>y</span><span class=o>::</span><span class=kt>Vector</span><span class=p>{</span><span class=kt>Float64</span><span class=p>};</span><span class=n>iters</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c># poor starting values</span>
</span></span><span class=line><span class=cl>    <span class=n>μ</span> <span class=o>=</span> <span class=p>[</span><span class=mf>4.0</span><span class=p>,</span><span class=mf>6.0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>σ</span> <span class=o>=</span> <span class=p>[</span><span class=mf>1.0</span><span class=p>,</span><span class=mf>1.0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>α</span> <span class=o>=</span> <span class=p>[</span><span class=mf>0.5</span><span class=p>,</span><span class=mf>0.5</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>N</span> <span class=o>=</span> <span class=n>length</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>K</span> <span class=o>=</span> <span class=n>length</span><span class=p>(</span><span class=n>μ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c># initialize objects    </span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>=</span> <span class=n>zeros</span><span class=p>(</span><span class=n>N</span><span class=p>,</span><span class=n>K</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>similar</span><span class=p>(</span><span class=n>L</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>it</span> <span class=k>in</span> <span class=mi>1</span><span class=o>:</span><span class=n>iters</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>dists</span> <span class=o>=</span> <span class=p>[</span><span class=n>Normal</span><span class=p>(</span><span class=n>μ</span><span class=p>[</span><span class=n>ik</span><span class=p>],</span> <span class=n>σ</span><span class=p>[</span><span class=n>ik</span><span class=p>]</span> <span class=p>)</span> <span class=k>for</span> <span class=n>ik</span> <span class=k>in</span> <span class=mi>1</span><span class=o>:</span><span class=n>K</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c># evaluate likelihood for each type </span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>1</span><span class=o>:</span><span class=n>N</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=k>in</span> <span class=mi>1</span><span class=o>:</span><span class=n>K</span>
</span></span><span class=line><span class=cl>                <span class=c># Distributions.jl logpdf()</span>
</span></span><span class=line><span class=cl>                <span class=n>L</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>log</span><span class=p>(</span><span class=n>α</span><span class=p>[</span><span class=n>k</span><span class=p>])</span> <span class=o>+</span> <span class=n>logpdf</span><span class=o>.</span><span class=p>(</span><span class=n>dists</span><span class=p>[</span><span class=n>k</span><span class=p>],</span> <span class=n>y</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> 
</span></span><span class=line><span class=cl>            <span class=k>end</span>
</span></span><span class=line><span class=cl>        <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c># get posterior of each type </span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=p>[</span><span class=o>:</span><span class=p>,</span><span class=o>:</span><span class=p>]</span> <span class=o>=</span> <span class=n>exp</span><span class=o>.</span><span class=p>(</span><span class=n>L</span> <span class=o>.-</span> <span class=n>logsumexp</span><span class=p>(</span><span class=n>L</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>        <span class=c># with p in hand, update </span>
</span></span><span class=line><span class=cl>        <span class=n>α</span><span class=p>[</span><span class=o>:</span><span class=p>]</span> <span class=o>.=</span> <span class=n>vec</span><span class=p>(</span><span class=n>sum</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=n>dims</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=o>./</span> <span class=n>N</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>μ</span><span class=p>[</span><span class=o>:</span><span class=p>]</span> <span class=o>.=</span> <span class=n>vec</span><span class=p>(</span><span class=n>sum</span><span class=p>(</span><span class=n>p</span> <span class=o>.*</span> <span class=n>y</span><span class=p>,</span> <span class=n>dims</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=o>./</span> <span class=n>sum</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>dims</span> <span class=o>=</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>σ</span><span class=p>[</span><span class=o>:</span><span class=p>]</span> <span class=o>.=</span> <span class=n>vec</span><span class=p>(</span><span class=n>sqrt</span><span class=o>.</span><span class=p>(</span><span class=n>sum</span><span class=p>(</span><span class=n>p</span> <span class=o>.*</span> <span class=p>(</span><span class=n>y</span> <span class=o>.-</span> <span class=n>μ</span><span class=o>&#39;</span><span class=p>)</span><span class=o>.^</span><span class=mi>2</span><span class=p>,</span> <span class=n>dims</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=o>./</span> <span class=n>sum</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>dims</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kt>Dict</span><span class=p>(</span><span class=ss>:α</span> <span class=o>=&gt;</span> <span class=n>α</span><span class=p>,</span> <span class=ss>:μ</span> <span class=o>=&gt;</span> <span class=n>μ</span><span class=p>,</span> <span class=ss>:σ</span> <span class=o>=&gt;</span> <span class=n>σ</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h3 id=gaussianmixturesjlhttpsgithubcomdavidavdavgaussianmixturesjl><a href=https://github.com/davidavdav/GaussianMixtures.jl target=_blank rel=noopener><code>GaussianMixtures.jl</code></a></h3><p>Next is a julia package written for this purpose. Here is the relevant part:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=k>function</span> <span class=n>bm_jl_GMM</span><span class=p>(</span><span class=n>y</span><span class=o>::</span><span class=kt>Vector</span><span class=p>{</span><span class=kt>Float64</span><span class=p>};</span><span class=n>iters</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>gmm</span> <span class=o>=</span> <span class=n>GMM</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>  <span class=c># initialize an empty GMM object</span>
</span></span><span class=line><span class=cl>    <span class=c># stick in our starting values</span>
</span></span><span class=line><span class=cl>    <span class=n>gmm</span><span class=o>.</span><span class=n>μ</span><span class=p>[</span><span class=o>:</span><span class=p>,</span><span class=mi>1</span><span class=p>]</span> <span class=o>.=</span> <span class=p>[</span><span class=mf>4.0</span><span class=p>;</span><span class=mf>6.0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>gmm</span><span class=o>.</span><span class=n>Σ</span><span class=p>[</span><span class=o>:</span><span class=p>,</span><span class=mi>1</span><span class=p>]</span> <span class=o>.=</span> <span class=p>[</span><span class=mf>1.0</span><span class=p>;</span><span class=mf>1.0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>gmm</span><span class=o>.</span><span class=n>w</span><span class=p>[</span><span class=o>:</span><span class=p>,</span><span class=mi>1</span><span class=p>]</span> <span class=o>.=</span> <span class=p>[</span><span class=mf>0.5</span><span class=p>;</span><span class=mf>0.5</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c># run em!</span>
</span></span><span class=line><span class=cl>    <span class=n>em!</span><span class=p>(</span><span class=n>gmm</span><span class=p>,</span><span class=n>y</span><span class=p>[</span><span class=o>:</span><span class=p>,</span><span class=o>:</span><span class=p>],</span><span class=n>nIter</span> <span class=o>=</span> <span class=n>iters</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>gmm</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h3 id=r-not-so-naive-by-hand><code>R</code> not-so-naive by hand</h3><ul><li>I tried to vectorize as much as possible here</li><li>Self-imposed rules: no <code>Rcpp</code></li><li>You can see this uses an <code>R</code>-string, where data values are interpolated with a <code>$</code> into the <code>R</code> session.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=c># this is a julia function!</span>
</span></span><span class=line><span class=cl><span class=k>function</span> <span class=n>bm_R</span><span class=p>(</span><span class=n>y</span><span class=p>;</span><span class=n>iters</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c># that defines an R-string, sent off to R.</span>
</span></span><span class=line><span class=cl>    <span class=n>r_result</span> <span class=o>=</span> <span class=sa>R</span><span class=s>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    library(tictoc)
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    # define a `repeat` function
</span></span></span><span class=line><span class=cl><span class=s>    spread &lt;- function (A, loc, dims) {
</span></span></span><span class=line><span class=cl><span class=s>        if (!(is.array(A))) {
</span></span></span><span class=line><span class=cl><span class=s>            A = array(A, dim = c(length(A)))
</span></span></span><span class=line><span class=cl><span class=s>        }
</span></span></span><span class=line><span class=cl><span class=s>        adims = dim(A)
</span></span></span><span class=line><span class=cl><span class=s>        l = length(loc)
</span></span></span><span class=line><span class=cl><span class=s>        if (max(loc) &gt; length(dim(A)) + l) {
</span></span></span><span class=line><span class=cl><span class=s>            stop(&#34;incorrect dimensions in spread&#34;)
</span></span></span><span class=line><span class=cl><span class=s>        }
</span></span></span><span class=line><span class=cl><span class=s>        sdim = c(dim(A), dims)
</span></span></span><span class=line><span class=cl><span class=s>        edim = c()
</span></span></span><span class=line><span class=cl><span class=s>        oi = 1
</span></span></span><span class=line><span class=cl><span class=s>        ni = length(dim(A)) + 1
</span></span></span><span class=line><span class=cl><span class=s>        for (i in c(1:(length(dim(A)) + l))) {
</span></span></span><span class=line><span class=cl><span class=s>            if (i %in% loc) {
</span></span></span><span class=line><span class=cl><span class=s>                edim = c(edim, ni)
</span></span></span><span class=line><span class=cl><span class=s>                ni = ni + 1
</span></span></span><span class=line><span class=cl><span class=s>            }
</span></span></span><span class=line><span class=cl><span class=s>            else {
</span></span></span><span class=line><span class=cl><span class=s>                edim = c(edim, oi)
</span></span></span><span class=line><span class=cl><span class=s>                oi = oi + 1
</span></span></span><span class=line><span class=cl><span class=s>            }
</span></span></span><span class=line><span class=cl><span class=s>        }
</span></span></span><span class=line><span class=cl><span class=s>        return(aperm(array(A, dim = sdim), edim))
</span></span></span><span class=line><span class=cl><span class=s>    }
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    # define row-wise logsumexp
</span></span></span><span class=line><span class=cl><span class=s>    logRowSumExp &lt;- function(M) {
</span></span></span><span class=line><span class=cl><span class=s>        if (is.null(dim(M))) {return(M)}
</span></span></span><span class=line><span class=cl><span class=s>        vms = apply(M,1,max)
</span></span></span><span class=line><span class=cl><span class=s>        log(rowSums(exp(M-spread(vms,2,dim(M)[2])))) + vms
</span></span></span><span class=line><span class=cl><span class=s>    }
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    # define the function to be timed in R
</span></span></span><span class=line><span class=cl><span class=s>    simpleEM &lt;- function(y,iters){
</span></span></span><span class=line><span class=cl><span class=s>    
</span></span></span><span class=line><span class=cl><span class=s>        K = 2
</span></span></span><span class=line><span class=cl><span class=s>        N = length(</span><span class=si>$y</span><span class=s>)
</span></span></span><span class=line><span class=cl><span class=s>        
</span></span></span><span class=line><span class=cl><span class=s>        EMfun &lt;- function(mu,sigma,alpha,iters){
</span></span></span><span class=line><span class=cl><span class=s>            # allocate arrays
</span></span></span><span class=line><span class=cl><span class=s>            p = array(0,c(N,K))
</span></span></span><span class=line><span class=cl><span class=s>            L = array(0,c(N,K))
</span></span></span><span class=line><span class=cl><span class=s>            
</span></span></span><span class=line><span class=cl><span class=s>            for (it in 1:iters){
</span></span></span><span class=line><span class=cl><span class=s>                # E step
</span></span></span><span class=line><span class=cl><span class=s>                
</span></span></span><span class=line><span class=cl><span class=s>                # vectorized over N loop
</span></span></span><span class=line><span class=cl><span class=s>                for (k in 1:K){
</span></span></span><span class=line><span class=cl><span class=s>                    L[ ,k] = log(alpha[k]) + dnorm(y,mean = mu[k], sd = sigma[k], log = TRUE)
</span></span></span><span class=line><span class=cl><span class=s>                }
</span></span></span><span class=line><span class=cl><span class=s>                p = exp(L - logRowSumExp(L))
</span></span></span><span class=line><span class=cl><span class=s>                
</span></span></span><span class=line><span class=cl><span class=s>                # M step
</span></span></span><span class=line><span class=cl><span class=s>                alpha = colMeans(p)
</span></span></span><span class=line><span class=cl><span class=s>                mu = colSums(p * y) / colSums(p)
</span></span></span><span class=line><span class=cl><span class=s>                sigma = sqrt( colSums( p * (y - spread(mu,1,N))^2 ) / colSums(p) )
</span></span></span><span class=line><span class=cl><span class=s>            }
</span></span></span><span class=line><span class=cl><span class=s>            o =list(alpha=alpha,mu=mu,sigma=sigma)
</span></span></span><span class=line><span class=cl><span class=s>            return(o)
</span></span></span><span class=line><span class=cl><span class=s>        }
</span></span></span><span class=line><span class=cl><span class=s>        
</span></span></span><span class=line><span class=cl><span class=s>        # starting values
</span></span></span><span class=line><span class=cl><span class=s>        mu_    = c(4.0,6.0)
</span></span></span><span class=line><span class=cl><span class=s>        sigma_ = c(1.0,1.0)
</span></span></span><span class=line><span class=cl><span class=s>        alpha_ = c(0.5,0.5)
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>        # take time
</span></span></span><span class=line><span class=cl><span class=s>        tic()
</span></span></span><span class=line><span class=cl><span class=s>        out = EMfun(mu_,sigma_,alpha_,iters)
</span></span></span><span class=line><span class=cl><span class=s>        tt = toc()
</span></span></span><span class=line><span class=cl><span class=s>        return(list(result = out, time = tt</span><span class=si>$toc</span><span class=s> - tt</span><span class=si>$tic</span><span class=s>))
</span></span></span><span class=line><span class=cl><span class=s>    }
</span></span></span><span class=line><span class=cl><span class=s>    simpleEM(</span><span class=si>$y</span><span class=s>,</span><span class=si>$iters</span><span class=s>)   # run function in R!
</span></span></span><span class=line><span class=cl><span class=s>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r_result</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h3 id=r-mixtools-package><code>R mixtools</code> package</h3><p>The <a href=https://cran.r-project.org/web/packages/mixtools/index.html target=_blank rel=noopener><code>mixtools</code></a> package is a very mature and highly optimized package for EM estimation. Most of the computationally intensive parts are written in <code>C</code>^[For example, in the package source, look for <code>src/normpost.c</code> which evaluates the matrix of posterior probabilities, object <code>p</code> in the julia code above. ]. My call:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=k>function</span> <span class=n>bm_R_mixtools</span><span class=p>(</span><span class=n>y</span><span class=o>::</span><span class=kt>Vector</span><span class=p>{</span><span class=kt>Float64</span><span class=p>};</span><span class=n>iters</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>r_result</span> <span class=o>=</span> <span class=sa>R</span><span class=s>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    library(tictoc)
</span></span></span><span class=line><span class=cl><span class=s>    library(mixtools)
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    mu    = c(4.0,6.0)
</span></span></span><span class=line><span class=cl><span class=s>    sigma = c(1.0,1.0)
</span></span></span><span class=line><span class=cl><span class=s>    alpha = c(0.5,0.5)
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    y = </span><span class=si>$y</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    N = length(y)
</span></span></span><span class=line><span class=cl><span class=s>    K = 2
</span></span></span><span class=line><span class=cl><span class=s>    iters = </span><span class=si>$iters</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    
</span></span></span><span class=line><span class=cl><span class=s>    tic()
</span></span></span><span class=line><span class=cl><span class=s>    result = normalmixEM(y,k = K,lambda = alpha, mu = mu, sigma = sigma, maxit = iters)
</span></span></span><span class=line><span class=cl><span class=s>    tt = toc()
</span></span></span><span class=line><span class=cl><span class=s>    list(result = result, time = tt</span><span class=si>$toc</span><span class=s> - tt</span><span class=si>$tic</span><span class=s>)
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r_result</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h2 id=results>Results!</h2><ul><li>I use the <a href=https://github.com/JuliaCI/BenchmarkTools.jl target=_blank rel=noopener><code>BenchmarkTools.jl</code></a> package to benchmark the julia functions. This runs the functions multiple times to account for system noise. (running multiple times also gets rid of any JIT-related delays in julia)</li><li>The <code>R</code> functions are timed <em>within</em> the R process using the <code>tictoc</code> package, so even if there were any significant overhead from <code>RCall.jl</code>, the measurement is immune to that.</li></ul><p>Here is the output table, with <code>n</code> for sample size, and times in seconds:</p><table><thead><tr><th>n</th><th>jl</th><th>jlg</th><th>R</th><th>Rmix</th></tr></thead><tbody><tr><td>10000</td><td>0.0388268</td><td>0.0179957</td><td>0.457</td><td>0.073</td></tr><tr><td>100000</td><td>0.366047</td><td>0.16506</td><td>5.068</td><td>0.889</td></tr><tr><td>1000000</td><td>3.99279</td><td>1.75384</td><td>47.522</td><td>8.344</td></tr><tr><td>10000000</td><td>46.833</td><td>31.4021</td><td>553.783</td><td>65.379</td></tr></tbody></table><p>And a much clearer picture using log scales:</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=/img/EM-bench.png alt=results loading=lazy data-zoomable></div></div></figure></p><h2 id=conclusions>Conclusions</h2><ol><li>The naively hand-written code in <code>julia</code> performs very well.</li><li>The <a href=https://github.com/davidavdav/GaussianMixtures.jl target=_blank rel=noopener><code>GaussianMixtures.jl</code></a> performs best throughout</li><li>Both julia implementations outperform the <code>C</code>-optimized
<a href=https://cran.r-project.org/web/packages/mixtools/index.html target=_blank rel=noopener><code>R mixtools</code></a> package.</li><li>The vectorized <code>R</code> version comes in slowest.</li></ol><p>I take from this that focusing on extending the work in <a href=https://github.com/davidavdav/GaussianMixtures.jl target=_blank rel=noopener><code>GaussianMixtures.jl</code></a> for my purposes is the most promising avenue here.</p><h2 id=code-and-versions>Code and Versions</h2><p>Code is on <a href=https://github.com/floswald/EMbench.jl target=_blank rel=noopener>github</a> with full package version manifest.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>julia</span><span class=o>&gt;</span> <span class=n>versioninfo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>Julia</span> <span class=n>Version</span> <span class=mf>1.1.0</span>
</span></span><span class=line><span class=cl><span class=n>Commit</span> <span class=mi>80516</span><span class=n>ca202</span> <span class=p>(</span><span class=mi>2019</span><span class=o>-</span><span class=mi>01</span><span class=o>-</span><span class=mi>21</span> <span class=mi>21</span><span class=o>:</span><span class=mi>24</span> <span class=n>UTC</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Platform</span> <span class=n>Info</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>OS</span><span class=o>:</span> <span class=n>macOS</span> <span class=p>(</span><span class=n>x86_64</span><span class=o>-</span><span class=n>apple</span><span class=o>-</span><span class=n>darwin14</span><span class=mf>.5.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>CPU</span><span class=o>:</span> <span class=n>Intel</span><span class=p>(</span><span class=n>R</span><span class=p>)</span> <span class=n>Core</span><span class=p>(</span><span class=n>TM</span><span class=p>)</span> <span class=n>i5</span><span class=o>-</span><span class=mi>5257</span><span class=n>U</span> <span class=n>CPU</span> <span class=err>@</span> <span class=mf>2.70</span><span class=n>GHz</span>
</span></span><span class=line><span class=cl>  <span class=n>WORD_SIZE</span><span class=o>:</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl>  <span class=n>LIBM</span><span class=o>:</span> <span class=n>libopenlibm</span>
</span></span><span class=line><span class=cl>  <span class=n>LLVM</span><span class=o>:</span> <span class=n>libLLVM</span><span class=o>-</span><span class=mf>6.0.1</span> <span class=p>(</span><span class=n>ORCJIT</span><span class=p>,</span> <span class=n>broadwell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>shell</span><span class=o>&gt;</span> <span class=n>R</span> <span class=o>--</span><span class=n>version</span>
</span></span><span class=line><span class=cl><span class=n>R</span> <span class=n>version</span> <span class=mf>3.5.1</span> <span class=p>(</span><span class=mi>2018</span><span class=o>-</span><span class=mi>07</span><span class=o>-</span><span class=mi>02</span><span class=p>)</span> <span class=o>--</span> <span class=s>&#34;Feather Spray&#34;</span>
</span></span><span class=line><span class=cl><span class=n>Copyright</span> <span class=p>(</span><span class=n>C</span><span class=p>)</span> <span class=mi>2018</span> <span class=n>The</span> <span class=n>R</span> <span class=n>Foundation</span> <span class=k>for</span> <span class=n>Statistical</span> <span class=n>Computing</span>
</span></span><span class=line><span class=cl><span class=n>Platform</span><span class=o>:</span> <span class=n>x86_64</span><span class=o>-</span><span class=n>apple</span><span class=o>-</span><span class=n>darwin15</span><span class=mf>.6.0</span> <span class=p>(</span><span class=mi>64</span><span class=o>-</span><span class=n>bit</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>R</span> <span class=n>is</span> <span class=n>free</span> <span class=n>software</span> <span class=n>and</span> <span class=n>comes</span> <span class=n>with</span> <span class=n>ABSOLUTELY</span> <span class=n>NO</span> <span class=n>WARRANTY</span><span class=o>.</span>
</span></span><span class=line><span class=cl><span class=n>You</span> <span class=n>are</span> <span class=n>welcome</span> <span class=n>to</span> <span class=n>redistribute</span> <span class=n>it</span> <span class=n>under</span> <span class=n>the</span> <span class=n>terms</span> <span class=n>of</span> <span class=n>the</span>
</span></span><span class=line><span class=cl><span class=n>GNU</span> <span class=n>General</span> <span class=n>Public</span> <span class=n>License</span> <span class=n>versions</span> <span class=mi>2</span> <span class=n>or</span> <span class=mf>3.</span>
</span></span><span class=line><span class=cl><span class=n>For</span> <span class=n>more</span> <span class=n>information</span> <span class=n>about</span> <span class=n>these</span> <span class=n>matters</span> <span class=n>see</span>
</span></span><span class=line><span class=cl><span class=n>http</span><span class=o>://</span><span class=n>www</span><span class=o>.</span><span class=n>gnu</span><span class=o>.</span><span class=n>org</span><span class=o>/</span><span class=n>licenses</span><span class=o>/.</span>
</span></span></code></pre></div></div><div class=article-tags><a class="badge badge-light" href=/tag/r/>R</a>
<a class="badge badge-light" href=/tag/julia/>julia</a>
<a class="badge badge-light" href=/tag/computing/>computing</a></div><div class=share-box><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https://floswald.github.io/post/em-benchmarks/&amp;text=EM%20Benchmarks" target=_blank rel=noopener class=share-btn-twitter aria-label=twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https://floswald.github.io/post/em-benchmarks/&amp;t=EM%20Benchmarks" target=_blank rel=noopener class=share-btn-facebook aria-label=facebook><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=EM%20Benchmarks&amp;body=https://floswald.github.io/post/em-benchmarks/" target=_blank rel=noopener class=share-btn-email aria-label=envelope><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https://floswald.github.io/post/em-benchmarks/&amp;title=EM%20Benchmarks" target=_blank rel=noopener class=share-btn-linkedin aria-label=linkedin-in><i class="fab fa-linkedin-in"></i></a></li><li><a href="whatsapp://send?text=EM%20Benchmarks%20https://floswald.github.io/post/em-benchmarks/" target=_blank rel=noopener class=share-btn-whatsapp aria-label=whatsapp><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=https://floswald.github.io/post/em-benchmarks/&amp;title=EM%20Benchmarks" target=_blank rel=noopener class=share-btn-weibo aria-label=weibo><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"><a href=https://floswald.github.io/><img class="avatar mr-3 avatar-circle" src=/authors/floswald/avatar_hucf967c33f389130ab619766a81118218_19547_270x270_fill_q75_lanczos_center.jpg alt="Florian Oswald"></a><div class=media-body><h5 class=card-title><a href=https://floswald.github.io/>Florian Oswald</a></h5><h6 class=card-subtitle>Associate Professor of Economics</h6><p class=card-text>I&rsquo;m interested in Urban/Macro/Labour/IO and computational methods</p><ul class=network-icon aria-hidden=true><li><a href=mailto:florian.oswald@sciencespo.fr><i class="fas fa-envelope"></i></a></li><li><a href=https://twitter.com/FlorianOswald target=_blank rel=noopener><i class="fab fa-twitter"></i></a></li><li><a href="https://scholar.google.com/citations?user=40Tdn0sAAAAJ" target=_blank rel=noopener><i class="fas fa-graduation-cap"></i></a></li><li><a href=https://github.com/floswald target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=/tex/floswald.pdf><i class="ai ai-cv"></i></a></li></ul></div></div></div></article></div><div class=page-footer><div class=container><footer class=site-footer><p class="powered-by copyright-license-text">© 2024 Me. This work is licensed under <a href=https://creativecommons.org/licenses/by-nc-nd/4.0 rel="noopener noreferrer" target=_blank>CC BY NC ND 4.0</a></p><p class="powered-by footer-license-icons"><a href=https://creativecommons.org/licenses/by-nc-nd/4.0 rel="noopener noreferrer" target=_blank aria-label="Creative Commons"><i class="fab fa-creative-commons fa-2x" aria-hidden=true></i>
<i class="fab fa-creative-commons-by fa-2x" aria-hidden=true></i>
<i class="fab fa-creative-commons-nc fa-2x" aria-hidden=true></i>
<i class="fab fa-creative-commons-nd fa-2x" aria-hidden=true></i></a></p><p class=powered-by>Published with <a href="https://wowchemy.com/?utm_campaign=poweredby" target=_blank rel=noopener>Wowchemy</a> — the free, <a href=https://github.com/wowchemy/wowchemy-hugo-themes target=_blank rel=noopener>open source</a> website builder that empowers creators.</p></footer></div></div><script src=/js/vendor-bundle.min.b4708d4364577c16ab7001b265a063a4.js></script><script id=search-hit-fuse-template type=text/x-template>
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script><script src=https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin=anonymous></script><script id=page-data type=application/json>{"use_headroom":true}</script><script src=/js/wowchemy-headroom.c251366b4128fd5e6b046d4c97a62a51.js type=module></script><script src=/en/js/wowchemy.min.42010733157c11a71adebfe9bae43355.js></script><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i> Copy
</a><a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i> Download</a><div id=modal-error></div></div></div></div></div><script src=/js/wowchemy-publication.af9327db0521d4a01354bfc8b77a4324.js type=module></script></body></html>